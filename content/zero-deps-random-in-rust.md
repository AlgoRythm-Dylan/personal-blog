+++
title = "Zero-dependency random number generation in Rust"
date = 2023-01-03

[taxonomies]
categories = ["Guides"]
+++

Let's investigate how to generate random numbers without external dependencies in Rust.

<!-- more -->

<center>

<img alt="https://xkcd.com/221/" src="/xkcd221.png"/>

</center>

<br>

Random numbers are very interesting. It feels like magic that we can generate such unpredictable entropies from deterministic sources.

But how does this happen? Before jumping into the generation of random numbers in Rust, let's understand the process of random number generation and how true randomness could never be created without special hardware.

### Is random really random?

First of all, nothing is _truly_ random when we consider the modern computers that we use on daily basis. This is because they are designed to be _deterministic_. What this means is that, given some initial state and an operation to perform, we can predict _exactly_ how the machine will evolve. Simply put, for the given inputs `2` and `2`, we know the operation `2+2` will be outputting `4`. This makes total sense since we don't want to wonder what an addition will do, we just want to 'add'. However, this situation of certainty is incompatible with generating _truly_ random numbers. From the definition of "truly", we understand that there should be absolutely no way to predict it, regardless of the information we have. Although it seems impossible to predict a random number without certain quantum-mechanical processes, since it would require knowing the state of every molecule in the atmosphere, we still cannot say that what we generate is _truly_ random.

But then, how do we generate 'random' numbers? Well, the answer is, in most cases, random is not so random. That's when [pseudorandomness](https://en.wikipedia.org/wiki/Pseudorandomness) steps into the scene.

> Pseudo-random sequences typically exhibit statistical randomness while being generated by an entirely deterministic causal process.

Pseudorandom number generators (**PRNG**s) are very important in computing. Without them, we wouldn't have encryption algorithms. They _emulate_ randomness by taking a statistically random sequence and using formulas to make it "random enough".

The math behind PRNG might be complex but in general, it requires two steps:

1. Provide the PRNG with an arbitrary **seed**.
2. Ask for the next random number.

The `seed` is a starting point for creating random numbers. If the seed changes, the generated numbers also change. If the same seed is used, the same number is generated. The current timestamp is often used as a unique seed value. That precise time never occurs again, so a PRNG with that seed should produce a unique set of random numbers.

Now that we understand how random is not _truly_ random and we can use pseudorandom with a seed to generate "random enough" numbers, let's see the ways of using PRNG in Rust and whether it is possible to do without extra dependencies. Unfortunately, there isn't a widely accepted and conventional way to generate random numbers by only using the core/standard library so we will have to be a little bit creative.

But hey, it will be fun!

---

### Using [`rand`](https://crates.io/crates/rand)

Probably the most straightforward of generating random numbers is using the `rand` crate.

Here are some [examples](https://rust-lang-nursery.github.io/rust-cookbook/algorithms/randomness.html):

```rs
use rand::Rng;

fn main() {
    let mut rng = rand::thread_rng();

    let n1: u8 = rng.gen();
    let n2: u16 = rng.gen();

    // Prints 57, 31141, 1371217128, 1901352909, 0.5792015593471697, etc.
    println!("Random u8: {}", n1);
    println!("Random u16: {}", n2);
    println!("Random u32: {}", rng.gen::<u32>());
    println!("Random i32: {}", rng.gen::<i32>());
    println!("Random float: {}", rng.gen::<f64>());
}
```

> Generates random numbers with help of random-number
> generator [`rand::Rng`](https://docs.rs/rand/_/rand/trait.Rng.html) obtained via [`rand::thread_rng`](https://docs.rs/rand/_/rand/fn.thread_rng.html). Each thread has an
> initialized generator. Integers are uniformly distributed over the range of the
> type, and floating point numbers are uniformly distributed from 0 up to but not
> including 1.

If we want to give a _seed_ and generate the same number every time we run the program, then we can change the PRNG implementation as follows:

```rs
use rand::{Rng, SeedableRng};
use rand_pcg::Pcg64;

const SEED: u64 = 42;

fn main() {
    // Uses PCG random number generator (XSL RR 128/64 (LCG) variant).
    let mut rng = Pcg64::seed_from_u64(SEED);

    // Prints "Random u8: 9" every time we run.
    println!("Random u8: {}", rng.gen::<u8>());
}
```

However, we're still far from our objective, which is generating random numbers without dependencies. Even `rand` with default features has several reverse dependencies:

```sh
$ cargo tree

testapp v0.1.0
└── rand v0.8.5
    ├── libc v0.2.139
    ├── rand_chacha v0.3.1
    │   ├── ppv-lite86 v0.2.17
    │   └── rand_core v0.6.4
    │       └── getrandom v0.2.8
    │           ├── cfg-if v1.0.0
    │           └── libc v0.2.139
    └── rand_core v0.6.4 (*)
```

Maybe we can look into reducing the reverse dependency count somehow before trying to achieve our 0-dependency goal.

I'm not sure how usable `rand` will be in this case, but we can simply remove the default features:

```toml
[dependencies]
rand = { version = "0.8.5", default-features = false }
```

Then we have:

```sh
$ cargo tree

testapp v0.1.0
└── rand v0.8.5
    └── rand_core v0.6.4
```

Still not looking good? Well, luckily, we have an alternative crate to use.

---

### Using [`fastrand`](https://crates.io/crates/fastrand)

`fastrand` is a simple and fast random number generator that uses [wyhash](https://github.com/wangyi-fudan/wyhash). This hash function is also simple and fast but not cryptographically secure.

So our previous examples with `rand` become the following:

```rs
fn main() {
    // Prints 119, 67, 233, etc.
    println!("Random u8: {}", fastrand::u8(..));

    // Pick an arbitrary number as seed.
    fastrand::seed(42);

    // Prints e.g. 52 every time we run.
    println!("Random u8 with seed: {}", fastrand::u8(..));
}
```

How about our dependency count?

```sh
$ cargo tree

testapp v0.1.0
└── fastrand v1.8.0
```

Well, it's good, but still not quite there. Technically, this approach is not 0-deps since `fastrand` itself is a dependency to our program.

Our goal is to have a single function that is simple enough for getting a random number every time we call it.

Hmm, let's see what we can do.

---

### **Zero-dependency Random Number Generation**

There is more than one way to simulate entropy to generate random numbers and I will be mentioning the most suggested/interesting ways that I came across on [Reddit](https://www.reddit.com/r/rust/comments/c1az1t/random_numbers_without_crates/) and [Rust users forum](https://users.rust-lang.org/t/random-number-without-using-the-external-crate/17260).

---

#### Nanoseconds

Here is the poor man's random number generator which only takes the nanoseconds of the current time:

```rs
use std::error::Error;
use std::time::{SystemTime, UNIX_EPOCH};

fn main() -> Result<(), Box<dyn Error>> {
    let nanos = SystemTime::now().duration_since(UNIX_EPOCH)?.subsec_nanos();

    // Prints 864479511, 455850730, etc.
    println!("Random number: {nanos}");
    Ok(())
}
```

In this example, we take the current time which is expressed as duration since [epoch](https://en.wikipedia.org/wiki/Unix_time), and extract the number of nanoseconds elapsed in the current second. For example, if the current time is "10:20:30.123456789" then our 'random' number will be 123456789. The problem here is that the number will be always between zero and 1 billion. We need to use a bit of modulo arithmetic to get a random number in the desired range.

Well, this was suboptimal. Let's see what else we can do.

---

#### `/dev/urandom`

> In Unix-like operating systems, `/dev/random` and `/dev/urandom` are special files that serve as cryptographically secure pseudorandom number generators. They allow access to environmental noise collected from device drivers and other sources.

The difference between `/dev/random` and `/dev/urandom` is that `/dev/random` only returns random bytes within the estimated number of bits of noise in the entropy pool whereas `/dev/urandom` does not block waiting for more entropy. Thus `/dev/urandom` is theoretically vulnerable to a cryptographic attack on the algorithms used by the driver and less random than `/dev/random`. `/dev/random` is more suitable for very high-quality randomness applications such as one-time pad or key generation.

(If you would like to learn more about these magical files, see [Myths about /dev/urandom](https://www.2uo.de/myths-about-urandom/))

In our case, we don't want to wait for the entropy pool until additional environmental noise is gathered so we can use `/dev/urandom`.

An example usage of `/dev/urandom` which generates a random string is the following:

```sh
$ cat /dev/urandom | base64 | head -c 10

66Dphl5MAh
```

In Rust, we can utilize `/dev/urandom` like so:

```rs
use std::fs::File;
use std::io::{Read, Result};

fn main() -> Result<()> {
    let mut rng = File::open("/dev/urandom")?;

    let mut buffer = [0u8; 1];
    rng.read_exact(&mut buffer)?;

    // Prints 92, 119, 122, etc.
    println!("Random u8: {}", buffer[0]);
    Ok(())
}
```

Although this solution will work perfectly fine on Unix-based operating systems, we won't be able to run this on other operating systems such as Microsoft Windows since `/dev/urandom` doesn't exist.

But hey, we got our RNG without extra dependencies!

```sh
$ cargo tree

testapp v0.1.0
```

Interestingly enough, [`OsRng`](https://docs.rs/rand/latest/rand/rngs/struct.OsRng.html) implementation of `rand` also depends on this approach:

> The implementation is provided by the [getrandom](https://crates.io/crates/getrandom) crate.

And `getrandom` crate reads `/dev/urandom` under the hood:

> Uses [getrandom](https://man7.org/linux/man-pages/man2/getrandom.2.html) system call if available, otherwise `/dev/urandom` after successfully polling `/dev/random`.

Wait, did I just read "getrandom system call"? I wonder if we can we utilize that for generating random numbers.

---

#### `getrandom(2)`

```c
#include <sys/random.h>

ssize_t getrandom(void *buf, size_t buflen, unsigned int flags);
```

> The `getrandom()` system call fills the buffer pointed to by `buf` with up to `buflen` random bytes.
> These bytes can be used to **seed** user-space random number generators or for cryptographic purposes.
> By default, `getrandom()` draws entropy from the urandom source (i.e., the same source as the `/dev/urandom` device).
> This behavior can be changed via the `flags` argument.

In order to use this system call in Rust, we need to define own our extern function or use the [libc](https://crates.io/crates/libc) crate since Unix systems expose the syscalls through `libc`.

```rs
// https://man7.org/linux/man-pages/man2/getrandom.2.html
#[cfg(not(target_os = "windows"))]
#[link(name = "c")]
extern "C" {
    fn getrandom(buf: *const u8, buflen: usize, flags: u32) -> usize;
}

fn main() {
    let buffer = [0u8; 1];
    unsafe { getrandom(buffer.as_ptr(), 1, 2) };

    // Prints 78, 51, 241, etc.
    println!("Seed: {:?}", buffer[0]);
}
```

In our example, we defined an extern function with the same name as our system call (`getrandom`) to link to C library on the system so that we can interoperate with the C code. When we run this program, we can see that random seeds are generated using the `getrandom()` system call.

The downside of this approach is that it will only work on systems that `getrandom()` system call exists and it is inescapably using `unsafe` code.

But yeah, it is 0-deps on the surface, except the system call itself.

---

#### `rand()` / `srand()`

```c
#include <stdlib.h>

int rand(void);
void srand(unsigned int seed);
```

Another external way of generating random numbers is to call the C library function [rand()](https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-rand-generate-random-number). Along with [srand()](https://www.ibm.com/docs/en/zos/2.2.0?topic=functions-srand-set-seed-rand-function), you can set the seed to use for a pseudorandom number generator. If `srand()` is not called, the `rand()` seed is set as if `srand(1)` was called at the program start.

We can implement this in Rust similar to `getrandom()` system call. For the seed, we can use the [nanoseconds](#nanoseconds):

```rs
use std::error::Error;
use std::time::{SystemTime, UNIX_EPOCH};

#[link(name = "c")]
extern "C" {
    fn rand() -> i32;
    fn srand(seed: u32);
}

fn main() -> Result<(), Box<dyn Error>> {
    let seed = SystemTime::now().duration_since(UNIX_EPOCH)?.subsec_nanos();

    unsafe {
        srand(seed);

        // Prints 1741856104, 1321400234, etc.
        println!("Random number: {}", rand());
    }

    Ok(())
}
```

This has the same disadvantages as `getrandom`, it requires the C library for linking and has `unsafe` code.

---

#### Raw pointers

Let's go for our last attempt.

The bottom line is, if we allocate something, take the pointer to it, retrieve the address, and cast it to an integer; we will get a random number. The address in the memory is not totally random, but probably random enough to do stuff™.

```rs
fn main() {
    let pointer = Box::into_raw(Box::new(42));

    // Prints 94560791661472, 94796207967136, etc.
    println!("Random number: {}", pointer as usize);
}
```

The problem with that approach is, apart from using a memory address for a random number, the numbers are always even since they are a memory address aligned to the size of an integer.

Also, the code above has memory leaks due to not handling the memory after calling [`Box::into_raw`](https://doc.rust-lang.org/std/boxed/struct.Box.html#method.into_raw).

```sh
$ valgrind -v target/debug/testapp

==985609== HEAP SUMMARY:
==985609==     in use at exit: 4 bytes in 1 blocks
==985609==   total heap usage: 12 allocs, 11 frees, 3,185 bytes allocated
==985609==
==985609== Searching for pointers to 1 not-freed blocks
==985609== Checked 110,200 bytes
==985609==
==985609== LEAK SUMMARY:
==985609==    definitely lost: 4 bytes in 1 blocks
==985609==    indirectly lost: 0 bytes in 0 blocks
==985609==      possibly lost: 0 bytes in 0 blocks
==985609==    still reachable: 0 bytes in 0 blocks
==985609==         suppressed: 0 bytes in 0 blocks
```

So we can edit the code as follows for manual cleanup by explicitly running the destructor and deallocating the memory:

```rs
use std::alloc::{dealloc, Layout};

fn main() {
    let pointer = Box::into_raw(Box::new(42));

    // Prints 94560791661472, 94796207967136, etc.
    println!("Random number: {}", pointer as usize);

    unsafe {
        std::ptr::drop_in_place(pointer);
        dealloc(pointer as *mut u8, Layout::new::<u32>());
    }
}
```

```sh
$ valgrind -v target/debug/testapp

==986501== HEAP SUMMARY:
==986501==     in use at exit: 0 bytes in 0 blocks
==986501==   total heap usage: 12 allocs, 12 frees, 3,185 bytes allocated
==986501==
==986501== All heap blocks were freed -- no leaks are possible
```

Yay! No leaks.

But... Damn. Why are we even dealing with this? Let's just use a raw pointer via `*const T`:

```rs
fn main() {
    let num = 42u8;
    let address = &num as *const u8;

    // Prints 140736885020951, 140731585258103, etc.
    println!("{}", address as usize);
}
```

In this example, obtaining an address like this is completely safe. But we will need to use `unsafe` Rust if we want to do anything with it.

---

### Final thoughts

Of course, there might be other ways to generate a random number without dependencies. This article aims to show the simplest ways without going too much into mathematical details.

Thanks to everyone who commented in the [forums thread](https://users.rust-lang.org/t/random-number-without-using-the-external-crate/17260/18), it was definitely helpful to read all the replies!

Let me know via the comments below if there are any other cool ways for generating random numbers.

See you next time! 🐻
